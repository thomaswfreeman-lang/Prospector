// app/api/enrich-prospects/route.ts
import { NextRequest, NextResponse } from 'next/server';

interface RawProspect {
  title: string;
  url: string;
  snippet: string;
  date?: string;
  source: string;
}

interface EnrichedProspect {
  title: string;
  url: string;
  snippet: string;
  date?: string;
  source: string;
  // Enriched fields
  summary: string;
  organization: string;
  implied_standard: string;
  likely_products: string[];
  fit_score: number;
  urgency: number;
  why_it_matters: string;
  contact_likelihood: number;
}

export async function POST(request: NextRequest) {
  try {
    const { prospects } = await request.json();
    
    if (!prospects || !Array.isArray(prospects)) {
      return NextResponse.json({ error: 'Invalid prospects array' }, { status: 400 });
    }

    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      return NextResponse.json({ error: 'OpenAI API key not configured' }, { status: 500 });
    }

    // Process in batches of 5 for efficiency
    const batchSize = 5;
    const enrichedProspects: EnrichedProspect[] = [];
    
    for (let i = 0; i < prospects.length; i += batchSize) {
      const batch = prospects.slice(i, i + batchSize);
      const enrichedBatch = await enrichBatch(batch, apiKey);
      enrichedProspects.push(...enrichedBatch);
    }

    // Sort by fit score descending
    enrichedProspects.sort((a, b) => b.fit_score - a.fit_score);

    return NextResponse.json({
      success: true,
      total_processed: prospects.length,
      enriched_prospects: enrichedProspects,
      high_priority: enrichedProspects.filter(p => p.fit_score >= 80),
      medium_priority: enrichedProspects.filter(p => p.fit_score >= 60 && p.fit_score < 80),
      processing_time: Date.now()
    });

  } catch (error) {
    console.error('Enrichment error:', error);
    return NextResponse.json({
      error: 'Enrichment failed',
      message: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
}

async function enrichBatch(prospects: RawProspect[], apiKey: string): Promise<EnrichedProspect[]> {
  const prompt = `You are a fire safety testing equipment sales intelligence analyst. Analyze these prospects and return JSON only.

INPUT PROSPECTS:
${prospects.map((p, i) => `${i + 1}. TITLE: ${p.title}
   URL: ${p.url}
   SNIPPET: ${p.snippet}
   SOURCE: ${p.source}`).join('\n\n')}

For each prospect, extract and score the following. Return a JSON array with this exact structure:

[
  {
    "prospect_number": 1,
    "summary": "1-2 sentence summary of why this matters for fire testing",
    "organization": "Organization/company name",
    "implied_standard": "Most likely testing standard (UL 94, ASTM E84, ISO 5660, NFPA 701, etc.)",
    "likely_products": ["product1", "product2"],
    "fit_score": 85,
    "urgency": 7,
    "why_it_matters": "Brief explanation of the opportunity",
    "contact_likelihood": 8
  }
]

SCORING GUIDELINES:
- fit_score (0-100): How well this matches fire testing equipment needs
- urgency (1-10): How soon they need a solution (based on dates, deadlines, language)
- contact_likelihood (1-10): How likely you can identify/reach decision makers

Focus on: RFPs, grants, procurement, research projects, facility upgrades, compliance needs.
High scores for: specific testing standards, equipment mentions, budget/timeline info.
Low scores for: vague mentions, old content, unrelated industries.

Return only valid JSON, no other text.`;

  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      model: 'gpt-4o-mini',
      messages: [{ role: 'user', content: prompt }],
      response_format: { type: 'json_object' },
      max_tokens: 3000,
      temperature: 0.3
    })
  });

  if (!response.ok) {
    throw new Error(`OpenAI API failed: ${response.status}`);
  }

  const data = await response.json();
  const content = data.choices[0]?.message?.content;
  
  if (!content) {
    throw new Error('No response from OpenAI');
  }

  try {
    const analysisResult = JSON.parse(content);
    const enrichedArray = Array.isArray(analysisResult) ? analysisResult : analysisResult.prospects || [];
    
    // Merge with original prospect data
    return prospects.map((original, index) => {
      const enrichment = enrichedArray[index] || {};
      return {
        ...original,
        summary: enrichment.summary || 'Analysis unavailable',
        organization: enrichment.organization || 'Unknown',
        implied_standard: enrichment.implied_standard || 'Not specified',
        likely_products: enrichment.likely_products || [],
        fit_score: enrichment.fit_score || 0,
        urgency: enrichment.urgency || 1,
        why_it_matters: enrichment.why_it_matters || 'Potential opportunity',
        contact_likelihood: enrichment.contact_likelihood || 1
      };
    });

  } catch (parseError) {
    console.error('JSON parse error:', parseError);
    // Return original prospects with minimal enrichment if parsing fails
    return prospects.map(p => ({
      ...p,
      summary: 'Enrichment failed',
      organization: 'Unknown',
      implied_standard: 'Not analyzed',
      likely_products: [],
      fit_score: 50,
      urgency: 5,
      why_it_matters: 'Requires manual review',
      contact_likelihood: 5
    }));
  }
}